{{- if and .Values.nfsServer.enabled (or (not .Values.nfsServer.network.serviceCIDR) (not .Values.nfsServer.network.staticIP)) }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "olake.fullname" . }}-nfs-cidr-detection
  namespace: {{ include "olake.namespace" . }}
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "-1"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
  labels:
    app.kubernetes.io/name: {{ include "olake.name" . }}-cidr-detection
    app.kubernetes.io/instance: {{ .Release.Name }}
    app.kubernetes.io/component: nfs-cidr-detection
    {{- include "olake.labels" . | nindent 4 }}
spec:
  backoffLimit: 3
  template:
    metadata:
      labels:
        app.kubernetes.io/name: {{ include "olake.name" . }}-cidr-detection
        app.kubernetes.io/instance: {{ .Release.Name }}
        app.kubernetes.io/component: nfs-cidr-detection
    spec:
      serviceAccountName: {{ include "olake.fullname" . }}-nfs-cidr-detection
      restartPolicy: Never
      containers:
      - name: cidr-detector
        image: bitnami/kubectl:latest
        imagePullPolicy: Always
        command:
        - /bin/bash
        - -c
        - |
          set -euo pipefail
          
          echo "INFO: Starting simplified CIDR detection..."
          
          # Check if user provided values in values.yaml
          USER_CIDR="{{ .Values.nfsServer.network.serviceCIDR }}"
          USER_STATIC_IP="{{ .Values.nfsServer.network.staticIP }}"
          
          if [ -n "$USER_CIDR" ] && [ -n "$USER_STATIC_IP" ]; then
            echo "INFO: Using user-provided configuration"
            FINAL_CIDR="$USER_CIDR"
            FINAL_STATIC_IP="$USER_STATIC_IP"
          else
            echo "INFO: Auto-detecting network configuration..."
            
            # Method 1: Environment variable (most reliable)
            if [ -n "$KUBERNETES_SERVICE_HOST" ] && [[ "$KUBERNETES_SERVICE_HOST" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              DETECTED_IP="$KUBERNETES_SERVICE_HOST"
              echo "INFO: Found kubernetes service IP from environment: $DETECTED_IP"
            # Method 2: DNS resolution (fallback)
            elif RESOLVED_IP=$(getent hosts kubernetes.default.svc.cluster.local 2>/dev/null | awk '{print $1}' | head -1); then
              if [[ "$RESOLVED_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                DETECTED_IP="$RESOLVED_IP"
                echo "INFO: Resolved kubernetes service IP via DNS: $DETECTED_IP"
              else
                echo "ERROR: Invalid IP from DNS resolution: $RESOLVED_IP"
                exit 1
              fi
            # Method 3: Error out
            else
              echo "ERROR: Cannot detect service CIDR automatically"
              echo "Please set nfsServer.network.serviceCIDR and nfsServer.network.staticIP in values.yaml"
              exit 1
            fi
            
            # CIDR inference based on detected IP
            echo "INFO: Inferring CIDR from detected IP: $DETECTED_IP"
            case "$DETECTED_IP" in
              10.96.*) 
                DETECTED_CIDR="10.96.0.0/12"
                echo "INFO: Detected standard kubeadm CIDR: $DETECTED_CIDR"
                ;;
              10.244.*) 
                DETECTED_CIDR="10.244.0.0/12"
                echo "INFO: Detected kind/flannel CIDR: $DETECTED_CIDR"
                ;;
              10.32.*) 
                DETECTED_CIDR="10.32.0.0/12"
                echo "INFO: Detected GKE CIDR: $DETECTED_CIDR"
                ;;
              172.*) 
                DETECTED_CIDR="172.16.0.0/12"
                echo "INFO: Detected private 172.x CIDR: $DETECTED_CIDR"
                ;;
              192.168.*) 
                DETECTED_CIDR="192.168.0.0/16"
                echo "INFO: Detected private 192.168.x CIDR: $DETECTED_CIDR"
                ;;
              *) 
                # Extract /16 for unknown ranges
                DETECTED_CIDR="$(echo "$DETECTED_IP" | cut -d. -f1,2).0.0/16"
                echo "INFO: Unknown range, using conservative /16 CIDR: $DETECTED_CIDR"
                ;;
            esac
            
            # Safe static IP calculation with high offset
            echo "INFO: Calculating static IP with high offset to avoid collisions..."
            NETWORK_BASE=$(echo "$DETECTED_CIDR" | cut -d'/' -f1)
            MASK=$(echo "$DETECTED_CIDR" | cut -d'/' -f2)
            
            # Parse network base IP
            IFS='.' read -r o1 o2 o3 o4 <<< "$NETWORK_BASE"
            
            # Calculate static IP based on mask
            case "$MASK" in
              12)
                # For /12 networks, use a different /24 subnet with high offset
                CALCULATED_STATIC_IP="${o1}.$((o2 + 4)).100.100"
                ;;
              16)
                # For /16 networks, use high third octet
                CALCULATED_STATIC_IP="${o1}.${o2}.200.100"
                ;;
              *)
                # Default: increment third octet significantly
                CALCULATED_STATIC_IP="${o1}.${o2}.$((o3 + 200)).100"
                ;;
            esac
            
            echo "INFO: Calculated static IP: $CALCULATED_STATIC_IP"
            
            # Use detected values or user overrides
            FINAL_CIDR="${USER_CIDR:-$DETECTED_CIDR}"
            FINAL_STATIC_IP="${USER_STATIC_IP:-$CALCULATED_STATIC_IP}"
          fi
          
          echo "INFO: Final configuration:"
          echo "  Service CIDR: $FINAL_CIDR"
          echo "  Static IP: $FINAL_STATIC_IP"
          
          # Create ConfigMap with final values
          kubectl create configmap {{ include "olake.fullname" . }}-nfs-ip-config \
            --from-literal=staticIP="$FINAL_STATIC_IP" \
            --from-literal=serviceCIDR="$FINAL_CIDR" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "SUCCESS: Network configuration completed successfully"
        resources:
          requests:
            memory: "64Mi"
            cpu: "100m"
          limits:
            memory: "128Mi"
            cpu: "200m"
{{- end }}